\documentclass[12pt,a4paper]{article} 
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage[left=3cm, right=3cm, top=2cm, bottom=2cm]{geometry}
\usepackage{graphicx}


\begin{document}
\newcommand{\parw}[2]{\dfrac{\partial #1}{\partial #2}}
\newcommand{\pl}{p_{\lambda}}
\newcommand{\pa}{p_{a}}
\newcommand{\mn}[1]{ \{ {#1} \} }
\newcommand{\pgm}{p_{m, \sigma^2}}
\newcommand{\pma}{p_{M, a}}
\newcommand{\xseqn}{x_1, \ldots, x_n}
\newcommand{\nd}[1]{\frac{1}{\sqrt{2 \pi #1^2}} \exp ( -{\frac{x^2}{2 #1^2}} ) }
\newcommand{\ndm}[2]{\frac{1}{\sqrt{2 \pi #2^2}} \exp ( - {\frac{(x - #1)^2}{2 #2^2}})}
\newcommand{\ndms}[3]{\frac{1}{(\sqrt{2 \pi #2^2})^n} \exp ( - \sum\limits_{i = 1}^{#3}{\frac{(x_i - #1)^2}{2 #2^2}})}
\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}

\binoppenalty=10000
\relpenalty=10000
\newcommand*{\hm}[1]{#1\nobreak\discretionary{}%
{\hbox{$\mathsurround=0pt #1$}}{}}

\begin{titlepage}
\begin{center}
\huge{\textbf{Конкурсная работа Acceler8 2011}

\bigskip
\Large{Поиск подматрицы с максимальной суммой элементов\\ на многоядерных ЭВМ с общей памятью}}
\end{center}

\begin{flushright}
\textbf{А.\,С. БОГАТЫЙ}

\textit{Московский государственный университет\\имени М. В. Ломоносова\\механико-математический факультет, 3 курс\\}
e-mail: bogatyia@gmail.com

\bigskip
\textbf{А.\,Р. ЛАПИН}

\textit{Московский государственный университет\\имени М. В. Ломоносова\\механико-математический факультет, 3 курс\\}
e-mail: lapinra@gmail.com\\[70pt]
\end{flushright}

\begin{center}
октябрь - ноябрь 2011
\end{center}
\end{titlepage}


\section{Введение}
Данная статья, в сущности, является описанием программы, написанной нашей командой для конкурса по параллельным алгоритмам \textbf{Acceler8 2011}  компании \textbf{Intel}, проводимого с 15 октября по 15 ноября 2011 года. 

Задача, поставленная перед участниками, заключалась в нахождении подматрицы с максимальной суммой элементов среди всех подматриц данной матрицы. В одном тесте может быть несколько матриц, каждая из которых имеет до 20000 строк и столбцов и генерируется по алгоритму, заданному в условии. Для каждой матрицы необходимо было вывести координаты угловых элементов, сумму элементов и площадь найденной подматрицы. При наличии нескольких подматриц с наибольшей суммой элементов ответом на задачу могла являться любая из них.

Критерием оценки решения являлась скорость работы программы на многоядерных машинах с различными конфигурациями при условии корректной работы программы (нахождения решений для всех матриц из данного теста за конечное время).

При создании нашей программы мы рассмотрели несколько последовательных алгоритмов: от самого простого решения перебором до более сложного алгоритма Джея Кадане (Jay Kadane). Мы предъявим способ распараллеливания алгоритма Кадане, рассмотрим особенности его реализации и предоставим сравнительный анализ полученных результатов.

\newpage
\section{Описание решения поставленной задачи}
Здесь и далее мы будем рассматривать случай, когда текущая матрица хранится в двумерном массиве, который полностью помещается в оперативную память.
\subsection{Наивный алгоритм}
Самым простым алгоритмом решения поставленной задачи является перебор всех возможных подматриц и подсчета суммы элементов для каждой из них.

Пусть матрица имеет $n$ строк и $m$ столбцов, тогда подсчет суммы ее элементов выполняется за $n \times m$ операций. Всего количество подматриц в матрице порядка $(n \cdot m)^2$ (тоже самое, что количество способов выбрать левый верхний и правый нижний углы подматрицы). В сумме мы получаем, что данный алгоритм работает за O($n^3 \cdot m^3$). 
\subsection{Наивный алгоритм с предподсчетом}
Попробуем улучшить предыдущий алгоритм, используя то, что матрица фиксирована и ее элементы не меняются.

Пусть нам дана матрица $A = (a_{ij})$ размера $n \times m$. Определим вспомогательную матрицу $B = b_{ij}$ следующим образом: элемент $b_{ij}$ есть сумма элементов подматрицы $A$, левый верхний элемент которой совпадает с левым верхним углом матрицы $A$, а правым нижним углом является элемент с индексами $i$ и $j$. 

\smallskip
\textbf{Утверждение 1:} Пусть матрица $B$ построена, тогда сумма элементов $s$ подматрицы с угловыми элементами $i_1, j_1$ и $i_2, j_2$ (левым верхним и правым нижним, соответственно) вычисляется по формуле: 
$$s = b_{i_2, j_2} - b_{i_1-1, j_2} - b_{i_2, j_1 - 1} + b_{i_1 - 1, j_1 - 1}$$

Это утверждение легко доказывается, если нарисовать наглядную картинку. По сути, берется сумма элементов большой матрицы, из нее вычитаются лишние куски и прибавляется та часть, которая была вычтена два раза.

\smallskip
\textbf{Утверждение 2:} Матрицу $B$ можно построить за $n \times m$ операций.

Это утверждение явно следует из формулы для элементов матрицы $B$: 
$$b_{i,j} = a_{i, j} + b_{i-1, j} + b_{i, j-1} - b_{i-1, j-1},$$
которая выводится из тех же соображений, что и формула из предыдущего утверждения.

\smallskip
Теперь мы можем сначала посчитать матрицу $B$, и, после этого, перебрать все подматрицы. Таким образом, мы получили алгоритм, работающий за O($n^2 \cdot m^2$) времени (т.к. сумма элементов любой подматрицы считается за O($1$)).

\subsection{Последовательный алгоритм Кадане}
Следующая оптимизация алгоритма вытекает из перестановки слагаемых в формуле из \textbf{утверждения 1}:
$$s = (b_{i_2, j_2} - b_{i_1-1, j_2}) - (b_{i_2, j_1 - 1} - b_{i_1 - 1, j_1 - 1})$$

Для двух фиксированных строк $i_1$ и $i_2$ мы можем перебирать правый столбец подматрицы, а левый столбец выбирать с минимальной разностью $(b_{i_2, j_1 - 1} - b_{i_1 - 1, j_1 - 1})$. Текущий минимум можно обновлять при переходе от стобца $j_2$ к столбцу $j_2+1$. Таким образом, получается алгоритм, работающий за O($n^2 \cdot m$) времени.

\subsection{Параллельный алгоритм Кадане}

За основу параллельного алгоритма мы взяли последовательный алгоритм Кадане, который заключался в переборе верхней строки, нижней строки и правого столбца  подматрицы, и распределили перебираемые верхние строки по потокам.

Пусть нам доступно $p$ потоков (процессоров/ядер), строки матрицы нумеруются от 1 до $n$, столбцы от 1 до $m$. Тогда в первом потоке будем обрабатывать случаи, когда верхней строкой подматрицы является строка с номером вида $1 + k p$, где $k \ge 0$, $1 + k p \le n$, во втором потоке - строка $2 + kp$, в $r$-ом потоке, соответственно, строка $r + kp$. Таким образом мы получаем равномерную загруженность всех доступных ядер.

\subsection{Особенности практической реализации}
Наше решение написано на языке \texttt{C} с использованием библиотеки \texttt{pthreads}. Приведем список примененных нами оптимизаций:

\smallskip
\noindent
1) Если писать параллельный алгоритм, отдавая каждому потоку по начальной строке и дальше идти по этой строке, то алгоритм выходит неэффективным с точки зрения L1 и L2 кэша, так как при каждой операции элемент нижней строки подматрицы не содержится ни в L1, ни в L2 кэше. Блочная версия алгоритма позволяет устранить этот недочет. Мы брали квадратные блоки со стороной кратной 4, чтобы эффективно работала оптимизация 2).
\begin{verbatim}
// Блок имеет размер BLOCK_ROW x BLOCK_COL
#define BLOCK_ROW 64
#define BLOCK_COL 64
\end{verbatim}
\noindent
2) Разгрузив оперативную память уже можно делать другие оптимизации, например, векторизацию. Но и тут есть подводные камни, алгоритм Кадана - это динамика и поэтому нельзя вычислять следующие элементы строк, не вычислив все предыдущие. Но можно заметить, что вычисления в строчках друг от друга никак не зависят, поэтому в один вектор можно уместить операции вычисления следующих элементов в 4-х строчках сразу. Для этого после копирования части матрицы в кэш, этот блок нужно транспонировать и грамотно организовать циклы.

\noindent
3) Мы делаем привязку \texttt{i}-го потока к \texttt{i}-ому ядру, чтобы соседние потоки имели общий кэш и процессоры обращались за памятью к своему \texttt{Numa} узлу:
\begin{verbatim}
  // Привязываем поток к процессору
  CPU_ZERO(&CPU_ID);
  CPU_SET(pargs->CPU_ID, &CPU_ID);  // pargs->CPU_ID - реальный номер потока
  sched_setaffinity(0, sizeof(cpu_set_t), &CPU_ID);  
\end{verbatim}


\noindent
4) Данный алгоритм генерации матрицы является псевдо-случайным, зависящим от одного последнего значения. Следовательно, можно найти прецикл и цикл этой последовательности. Если $L$ -- длина цикла, тогда это можно сделать за O($L$) шагов, например при помощи $\rho$ - эвристики Полларда. Найдя цикл, оставшиеся элементы вычисляются без применения арифметический операций, и, таким образом, программа значительно ускоряется.


\bigskip
\noindent
5) Вычислив предцикл и цикл матрицу можно генерировать в нескольких потоках, что дает значительное ускорение на больших матрицах.


\bigskip
\noindent
6) Мы обрабатываем параллельно несколько кейсов, где количество потоков на конкретный кейс зависит от размеров матрицы. Например, на матрицы, которые помещяются в L3 кэш мы отводим не более 10 потоков.


\bigskip
\noindent
7) Верно следующее утверждение:

\smallskip
\textbf{Утверждение 3:} Всегда существует подматрица с максимальной суммой чисел, у которой верхняя строка находится не ниже строки с номером $M$, где $M$ -- число различных строк в матрице.

\smallskip
Число $M$ не больше, чем число, по модулю которого генерируется матрица. При этом $M$ обычно много меньше этого числа и его можно найти за время O(n), рассматривая количество различных чисел в первом столбце. Таким образом верхнюю строку можно перебирать до $M$.


\newpage
\subsection{Сравнение времени работы программы при разном количестве используемых процессоров}
Замеры проводились на тесте из 1 тест кейса -- \texttt{19170 19471 4244 632 5183 15601}. Это - первый тест из \texttt{huge.txt}, выданного организаторами. Мы взяли только 1 кейс, чтобы проверить качество распараллеливания самого алгоритма, а не системы параллельной обработки нескольких кейсов сразу. 
\\
\\
\begin{tabular}{|c|c|c|}
\hline 
$\text{Количество процессоров}$ & $\text{Время (sec)}$ & $\text{Ускорение} $ \\ 
\hline 
$1$ & $1767.19$ &  $1.00$ \\ 
\hline 
$2$ & $885.30$  &  $1.99$ \\ 
\hline 
$4$ & $448.59$  &  $3.93$ \\ 
\hline 
$10$ & $184.74$ & $9.56$ \\ 
\hline 
$20$ & $94.47$ & $18.70$ \\ 
\hline 
$40$ & $51.13$ & $34.56$ \\
\hline
\end{tabular}

\section{Заключение}

В результате работы нами был получен эффективный алгоритм решения задачи. Причём на случайных матрицах(с большим размером цикла) наш параллельный алгоритм оказался весьма выгодным -- ускорение почти в 35 раз на 40-ка ядрах. Но и эту константу можно увеличить, если более аккуратно работать с \texttt{Numa} системой, однако это потребует дополнительного объема оперативной памяти, которой и так может нехватать на слабой машине. В целом мы довольны проделанной работой, т.к. в процессе конкурса узнали много нового - векторизация вычислений, компиляторы \texttt{intel}, привязка потоков и впервые попробовали силы на действительно "многоядерной" машине, а не на 4-х ядерных поделках.

\begin{thebibliography}{99}
\bibitem{bogachev_book}
\textit{Богачев К.\,Ю. } Основы параллельного программирования. М.: Бином, 2003.
\bibitem{bogachev_article}
\textit{Богачев К.\,Ю., Миргасимов А.\,Р.} Об оптимизации вычислительных приложений для многопроцессорных систем с общей неоднородной памятью // Вычислительные методы и программирование. 2010. Т. 11
\end{thebibliography}

\end{document}


